
#### 使用十进制转二进制的方法
```C#
auto bitCount = [](int x) {
	int cnt = 0;
	while (x) {
		cnt += (x % 2);
		x /= 2;
	}
	return cnt;
};

```
每次通过 $i mod 2$ 得到最低的二进制位，在通过 $\lfloor i / 2\rfloor$去掉最低的二进制位（其中 $⌊⋅⌋$ 表示向下取整），不断进行该操作直到 i=0 为止。

#### 正整数与其小1的数相与
此方法与[[判断数是否是2的幂次]]有关
```C#
while(tmp != 0) {
	tmp &= tmp - 1;
	++cnt;
}
```

#### 对计算置位个数进行优化
**思路与算法

我们可以对计算置位个数的代码进行优化。

在本题中，下标的最大值为 $10^3−1$，它对应的二进制数有 10 位，我们用 $(abcdefghij)_2$ 来表示。本质上，我们希望快速得到：
$${align}a+b+c+d+e+f+g+h+i+j \tag{1}$$
的值。我们可以使用分治的思想，进行如下的三步操作：

* 第一步将 $(abcdefghij)_2$ 拆分成两个二进制数 $(0a0c0e0g0i)_2$ 与 $(0b0d0f0h0j)_2$ 。我们将它们直接相加，由于 0+0 一定不会产生进位，因此我们两位两位地看这个加法操作，它们之间是相互不会影响的，例如 $(0a)2+(0b)$ ，得到的结果实际上就是 $a+b$ 对应的二进制数。这样一来，加法操作得到的新数 $(abcdefghij)_2$ ，其中：
$$\overline{ab}+\overline{cd}+\overline{ef}+\overline{gh}+\overline{ij} \tag{2}$$
的值与 (1)式是相同的，这里 $\overline{ab}$  表示将 $ab$ 看成一个两位的二进制数，计算其十进制的值。

* 第二步是类似的，将新的 $(abcdefghij)_2$ 拆分成两个二进制数 $(ab00ef00ij)_2$ 与 $(00cd00gh)_2$ ，并直接相加。我们四位四位地看这个加法操作，它们之间是相互不会影响的。这样一来，加法操作得到的新数 $(abcdefghij)_2$ ，其中：
$$\overline{ab} + \overline{cdef} + \overline{ghij} \tag{3}$$
的值与 (1) 式是相同的。

* 第三步时，我们只剩下三个部分，因此无需继续分治，直接计算 (3) 式的值即可。
在编写代码时，我们需要使用位运算。三步操作分别对应着：

* 通过 x & 0101010101 得到 $(0a0c0e0g0i)_2$  ，以及 (x & 1010101010) >> 1 得到$(0b0d0f0h0j)_2$ 。

* 通过 x & 1100110011 得到 $(ab00ef00ij)_2$  ，以及 (x & 0011001100) >> 2 得到 $(00cd00gh)_2$。

* 通过 x >> 8 得到 $(ab)_2$ ，以及 (x >> 4) & 1111 得到 $(cdef)_2$ ，以及 x & 1111 得到 $(ghij)_2$。

作者：力扣官方题解
链接：https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/solutions/2614602/ji-suan-k-zhi-wei-xia-biao-dui-ying-yuan-axzr/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。